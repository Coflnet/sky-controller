// Code generated by ogen, DO NOT EDIT.

package api

import (
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/json"
)

// Encode encodes Category as json.
func (s Category) Encode(e *jx.Encoder) {
	e.Int32(int32(s))
}

// Decode decodes Category from json.
func (s *Category) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Category to nil")
	}
	v, err := d.Int32()
	if err != nil {
		return err
	}
	*s = Category(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Category) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Category) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Enchantment) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Enchantment) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Level.Set {
			e.FieldStart("level")
			s.Level.Encode(e)
		}
	}
	{
		if s.ItemType.Set {
			e.FieldStart("itemType")
			s.ItemType.Encode(e)
		}
	}
	{
		if s.SaveAuctionId.Set {
			e.FieldStart("saveAuctionId")
			s.SaveAuctionId.Encode(e)
		}
	}
}

var jsonFieldsNameOfEnchantment = [5]string{
	0: "id",
	1: "type",
	2: "level",
	3: "itemType",
	4: "saveAuctionId",
}

// Decode decodes Enchantment from json.
func (s *Enchantment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Enchantment to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "level":
			if err := func() error {
				s.Level.Reset()
				if err := s.Level.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "itemType":
			if err := func() error {
				s.ItemType.Reset()
				if err := s.ItemType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"itemType\"")
			}
		case "saveAuctionId":
			if err := func() error {
				s.SaveAuctionId.Reset()
				if err := s.SaveAuctionId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"saveAuctionId\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Enchantment")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Enchantment) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Enchantment) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnchantmentType as json.
func (s EnchantmentType) Encode(e *jx.Encoder) {
	e.Int32(int32(s))
}

// Decode decodes EnchantmentType from json.
func (s *EnchantmentType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnchantmentType to nil")
	}
	v, err := d.Int32()
	if err != nil {
		return err
	}
	*s = EnchantmentType(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EnchantmentType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnchantmentType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *KeyCreate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *KeyCreate) encodeFields(e *jx.Encoder) {
	{
		if s.Party.Set {
			e.FieldStart("party")
			s.Party.Encode(e)
		}
	}
	{
		if s.Key.Set {
			e.FieldStart("key")
			s.Key.Encode(e)
		}
	}
	{
		if s.Owner.Set {
			e.FieldStart("owner")
			s.Owner.Encode(e)
		}
	}
}

var jsonFieldsNameOfKeyCreate = [3]string{
	0: "party",
	1: "key",
	2: "owner",
}

// Decode decodes KeyCreate from json.
func (s *KeyCreate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode KeyCreate to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "party":
			if err := func() error {
				s.Party.Reset()
				if err := s.Party.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"party\"")
			}
		case "key":
			if err := func() error {
				s.Key.Reset()
				if err := s.Key.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "owner":
			if err := func() error {
				s.Owner.Reset()
				if err := s.Owner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode KeyCreate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *KeyCreate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *KeyCreate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NBTLookup) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NBTLookup) encodeFields(e *jx.Encoder) {
	{
		if s.AuctionId.Set {
			e.FieldStart("auctionId")
			s.AuctionId.Encode(e)
		}
	}
	{
		if s.KeyId.Set {
			e.FieldStart("keyId")
			s.KeyId.Encode(e)
		}
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
}

var jsonFieldsNameOfNBTLookup = [3]string{
	0: "auctionId",
	1: "keyId",
	2: "value",
}

// Decode decodes NBTLookup from json.
func (s *NBTLookup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NBTLookup to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "auctionId":
			if err := func() error {
				s.AuctionId.Reset()
				if err := s.AuctionId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auctionId\"")
			}
		case "keyId":
			if err := func() error {
				s.KeyId.Reset()
				if err := s.KeyId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keyId\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NBTLookup")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NBTLookup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NBTLookup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NbtData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NbtData) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfNbtData = [2]string{
	0: "id",
	1: "data",
}

// Decode decodes NbtData from json.
func (s *NbtData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NbtData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NbtData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NbtData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NbtData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s NbtDataData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s NbtDataData) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes NbtDataData from json.
func (s *NbtDataData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NbtDataData to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NbtDataData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NbtDataData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NbtDataData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Category as json.
func (o OptCategory) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int32(int32(o.Value))
}

// Decode decodes Category from json.
func (o *OptCategory) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCategory to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCategory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCategory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes EnchantmentType as json.
func (o OptEnchantmentType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int32(int32(o.Value))
}

// Decode decodes EnchantmentType from json.
func (o *OptEnchantmentType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEnchantmentType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEnchantmentType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEnchantmentType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int32 as json.
func (o OptInt32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int32(int32(o.Value))
}

// Decode decodes int32 from json.
func (o *OptInt32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt32 to nil")
	}
	o.Set = true
	v, err := d.Int32()
	if err != nil {
		return err
	}
	o.Value = int32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int64 as json.
func (o OptInt64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int64(int64(o.Value))
}

// Decode decodes int64 from json.
func (o *OptInt64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt64 to nil")
	}
	o.Set = true
	v, err := d.Int64()
	if err != nil {
		return err
	}
	o.Value = int64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NbtData as json.
func (o OptNbtData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NbtData from json.
func (o *OptNbtData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNbtData to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNbtData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNbtData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []jx.Raw as json.
func (o OptNilAnyArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	e.ArrEnd()
}

// Decode decodes []jx.Raw from json.
func (o *OptNilAnyArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilAnyArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []jx.Raw
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]jx.Raw, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem jx.Raw
		v, err := d.RawAppend(nil)
		elem = jx.Raw(v)
		if err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilAnyArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilAnyArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []Enchantment as json.
func (o OptNilEnchantmentArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes []Enchantment from json.
func (o *OptNilEnchantmentArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilEnchantmentArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []Enchantment
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]Enchantment, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem Enchantment
		if err := elem.Decode(d); err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilEnchantmentArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilEnchantmentArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []NBTLookup as json.
func (o OptNilNBTLookupArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes []NBTLookup from json.
func (o *OptNilNBTLookupArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilNBTLookupArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []NBTLookup
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]NBTLookup, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem NBTLookup
		if err := elem.Decode(d); err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilNBTLookupArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilNBTLookupArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NbtDataData as json.
func (o OptNilNbtDataData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NbtDataData from json.
func (o *OptNilNbtDataData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilNbtDataData to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v NbtDataData
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(NbtDataData)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilNbtDataData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilNbtDataData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SaveAuctionContext as json.
func (o OptNilSaveAuctionContext) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SaveAuctionContext from json.
func (o *OptNilSaveAuctionContext) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilSaveAuctionContext to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v SaveAuctionContext
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(SaveAuctionContext)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilSaveAuctionContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilSaveAuctionContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SaveAuctionFlatNbt as json.
func (o OptNilSaveAuctionFlatNbt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SaveAuctionFlatNbt from json.
func (o *OptNilSaveAuctionFlatNbt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilSaveAuctionFlatNbt to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v SaveAuctionFlatNbt
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(SaveAuctionFlatNbt)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilSaveAuctionFlatNbt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilSaveAuctionFlatNbt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SaveAuctionTraceContext as json.
func (o OptNilSaveAuctionTraceContext) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SaveAuctionTraceContext from json.
func (o *OptNilSaveAuctionTraceContext) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilSaveAuctionTraceContext to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v SaveAuctionTraceContext
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(SaveAuctionTraceContext)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilSaveAuctionTraceContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilSaveAuctionTraceContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []SaveBids as json.
func (o OptNilSaveBidsArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes []SaveBids from json.
func (o *OptNilSaveBidsArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilSaveBidsArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []SaveBids
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]SaveBids, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem SaveBids
		if err := elem.Decode(d); err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilSaveBidsArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilSaveBidsArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptNilString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptNilString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilString to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v string
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []string as json.
func (o OptNilStringArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		e.Str(elem)
	}
	e.ArrEnd()
}

// Decode decodes []string from json.
func (o *OptNilStringArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilStringArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []string
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]string, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem string
		v, err := d.Str()
		elem = string(v)
		if err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilStringArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilStringArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []UUID as json.
func (o OptNilUUIDArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes []UUID from json.
func (o *OptNilUUIDArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilUUIDArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []UUID
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]UUID, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem UUID
		if err := elem.Decode(d); err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilUUIDArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilUUIDArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Reforge as json.
func (o OptReforge) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int32(int32(o.Value))
}

// Decode decodes Reforge from json.
func (o *OptReforge) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReforge to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptReforge) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptReforge) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SaveAuction as json.
func (o OptSaveAuction) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SaveAuction from json.
func (o *OptSaveAuction) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSaveAuction to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSaveAuction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSaveAuction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Tier as json.
func (o OptTier) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int32(int32(o.Value))
}

// Decode decodes Tier from json.
func (o *OptTier) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTier to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProxyHypixelGetOKApplicationJSON as json.
func (s ProxyHypixelGetOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes ProxyHypixelGetOKApplicationJSON from json.
func (s *ProxyHypixelGetOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProxyHypixelGetOKApplicationJSON to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProxyHypixelGetOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ProxyHypixelGetOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProxyHypixelGetOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Reforge as json.
func (s Reforge) Encode(e *jx.Encoder) {
	e.Int32(int32(s))
}

// Decode decodes Reforge from json.
func (s *Reforge) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Reforge to nil")
	}
	v, err := d.Int32()
	if err != nil {
		return err
	}
	*s = Reforge(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Reforge) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Reforge) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SaveAuction) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SaveAuction) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.UUID.Set {
			e.FieldStart("uuid")
			s.UUID.Encode(e)
		}
	}
	{
		if s.Claimed.Set {
			e.FieldStart("claimed")
			s.Claimed.Encode(e)
		}
	}
	{
		if s.Count.Set {
			e.FieldStart("count")
			s.Count.Encode(e)
		}
	}
	{
		if s.StartingBid.Set {
			e.FieldStart("startingBid")
			s.StartingBid.Encode(e)
		}
	}
	{
		if s.OldTier.Set {
			e.FieldStart("oldTier")
			s.OldTier.Encode(e)
		}
	}
	{
		if s.OldCategory.Set {
			e.FieldStart("oldCategory")
			s.OldCategory.Encode(e)
		}
	}
	{
		if s.Tag.Set {
			e.FieldStart("tag")
			s.Tag.Encode(e)
		}
	}
	{
		if s.ItemName.Set {
			e.FieldStart("itemName")
			s.ItemName.Encode(e)
		}
	}
	{
		if s.Start.Set {
			e.FieldStart("start")
			s.Start.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.End.Set {
			e.FieldStart("end")
			s.End.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.AuctioneerId.Set {
			e.FieldStart("auctioneerId")
			s.AuctioneerId.Encode(e)
		}
	}
	{
		if s.ProfileId.Set {
			e.FieldStart("profileId")
			s.ProfileId.Encode(e)
		}
	}
	{
		if s.Coop.Set {
			e.FieldStart("coop")
			s.Coop.Encode(e)
		}
	}
	{
		if s.CoopMembers.Set {
			e.FieldStart("coopMembers")
			s.CoopMembers.Encode(e)
		}
	}
	{
		if s.ClaimedBidders.Set {
			e.FieldStart("claimedBidders")
			s.ClaimedBidders.Encode(e)
		}
	}
	{
		if s.ClaimedBids.Set {
			e.FieldStart("claimedBids")
			s.ClaimedBids.Encode(e)
		}
	}
	{
		if s.HighestBidAmount.Set {
			e.FieldStart("highestBidAmount")
			s.HighestBidAmount.Encode(e)
		}
	}
	{
		if s.Bids.Set {
			e.FieldStart("bids")
			s.Bids.Encode(e)
		}
	}
	{
		if s.AnvilUses.Set {
			e.FieldStart("anvilUses")
			s.AnvilUses.Encode(e)
		}
	}
	{
		if s.Enchantments.Set {
			e.FieldStart("enchantments")
			s.Enchantments.Encode(e)
		}
	}
	{
		if s.NbtData.Set {
			e.FieldStart("nbtData")
			s.NbtData.Encode(e)
		}
	}
	{
		if s.ItemCreatedAt.Set {
			e.FieldStart("itemCreatedAt")
			s.ItemCreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Reforge.Set {
			e.FieldStart("reforge")
			s.Reforge.Encode(e)
		}
	}
	{
		if s.Category.Set {
			e.FieldStart("category")
			s.Category.Encode(e)
		}
	}
	{
		if s.Tier.Set {
			e.FieldStart("tier")
			s.Tier.Encode(e)
		}
	}
	{
		if s.Bin.Set {
			e.FieldStart("bin")
			s.Bin.Encode(e)
		}
	}
	{
		if s.SellerId.Set {
			e.FieldStart("sellerId")
			s.SellerId.Encode(e)
		}
	}
	{
		if s.ItemId.Set {
			e.FieldStart("itemId")
			s.ItemId.Encode(e)
		}
	}
	{
		if s.NbtLookup.Set {
			e.FieldStart("nbtLookup")
			s.NbtLookup.Encode(e)
		}
	}
	{
		if s.FlatNbt.Set {
			e.FieldStart("flatNbt")
			s.FlatNbt.Encode(e)
		}
	}
	{
		if s.UID.Set {
			e.FieldStart("uId")
			s.UID.Encode(e)
		}
	}
	{
		if s.FindTime.Set {
			e.FieldStart("findTime")
			s.FindTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.TraceContext.Set {
			e.FieldStart("traceContext")
			s.TraceContext.Encode(e)
		}
	}
	{
		if s.Context.Set {
			e.FieldStart("context")
			s.Context.Encode(e)
		}
	}
}

var jsonFieldsNameOfSaveAuction = [35]string{
	0:  "id",
	1:  "uuid",
	2:  "claimed",
	3:  "count",
	4:  "startingBid",
	5:  "oldTier",
	6:  "oldCategory",
	7:  "tag",
	8:  "itemName",
	9:  "start",
	10: "end",
	11: "auctioneerId",
	12: "profileId",
	13: "coop",
	14: "coopMembers",
	15: "claimedBidders",
	16: "claimedBids",
	17: "highestBidAmount",
	18: "bids",
	19: "anvilUses",
	20: "enchantments",
	21: "nbtData",
	22: "itemCreatedAt",
	23: "reforge",
	24: "category",
	25: "tier",
	26: "bin",
	27: "sellerId",
	28: "itemId",
	29: "nbtLookup",
	30: "flatNbt",
	31: "uId",
	32: "findTime",
	33: "traceContext",
	34: "context",
}

// Decode decodes SaveAuction from json.
func (s *SaveAuction) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SaveAuction to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "uuid":
			if err := func() error {
				s.UUID.Reset()
				if err := s.UUID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "claimed":
			if err := func() error {
				s.Claimed.Reset()
				if err := s.Claimed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"claimed\"")
			}
		case "count":
			if err := func() error {
				s.Count.Reset()
				if err := s.Count.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"count\"")
			}
		case "startingBid":
			if err := func() error {
				s.StartingBid.Reset()
				if err := s.StartingBid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startingBid\"")
			}
		case "oldTier":
			if err := func() error {
				s.OldTier.Reset()
				if err := s.OldTier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"oldTier\"")
			}
		case "oldCategory":
			if err := func() error {
				s.OldCategory.Reset()
				if err := s.OldCategory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"oldCategory\"")
			}
		case "tag":
			if err := func() error {
				s.Tag.Reset()
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "itemName":
			if err := func() error {
				s.ItemName.Reset()
				if err := s.ItemName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"itemName\"")
			}
		case "start":
			if err := func() error {
				s.Start.Reset()
				if err := s.Start.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start\"")
			}
		case "end":
			if err := func() error {
				s.End.Reset()
				if err := s.End.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end\"")
			}
		case "auctioneerId":
			if err := func() error {
				s.AuctioneerId.Reset()
				if err := s.AuctioneerId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auctioneerId\"")
			}
		case "profileId":
			if err := func() error {
				s.ProfileId.Reset()
				if err := s.ProfileId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileId\"")
			}
		case "coop":
			if err := func() error {
				s.Coop.Reset()
				if err := s.Coop.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"coop\"")
			}
		case "coopMembers":
			if err := func() error {
				s.CoopMembers.Reset()
				if err := s.CoopMembers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"coopMembers\"")
			}
		case "claimedBidders":
			if err := func() error {
				s.ClaimedBidders.Reset()
				if err := s.ClaimedBidders.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"claimedBidders\"")
			}
		case "claimedBids":
			if err := func() error {
				s.ClaimedBids.Reset()
				if err := s.ClaimedBids.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"claimedBids\"")
			}
		case "highestBidAmount":
			if err := func() error {
				s.HighestBidAmount.Reset()
				if err := s.HighestBidAmount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"highestBidAmount\"")
			}
		case "bids":
			if err := func() error {
				s.Bids.Reset()
				if err := s.Bids.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bids\"")
			}
		case "anvilUses":
			if err := func() error {
				s.AnvilUses.Reset()
				if err := s.AnvilUses.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"anvilUses\"")
			}
		case "enchantments":
			if err := func() error {
				s.Enchantments.Reset()
				if err := s.Enchantments.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enchantments\"")
			}
		case "nbtData":
			if err := func() error {
				s.NbtData.Reset()
				if err := s.NbtData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nbtData\"")
			}
		case "itemCreatedAt":
			if err := func() error {
				s.ItemCreatedAt.Reset()
				if err := s.ItemCreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"itemCreatedAt\"")
			}
		case "reforge":
			if err := func() error {
				s.Reforge.Reset()
				if err := s.Reforge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reforge\"")
			}
		case "category":
			if err := func() error {
				s.Category.Reset()
				if err := s.Category.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"category\"")
			}
		case "tier":
			if err := func() error {
				s.Tier.Reset()
				if err := s.Tier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tier\"")
			}
		case "bin":
			if err := func() error {
				s.Bin.Reset()
				if err := s.Bin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bin\"")
			}
		case "sellerId":
			if err := func() error {
				s.SellerId.Reset()
				if err := s.SellerId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sellerId\"")
			}
		case "itemId":
			if err := func() error {
				s.ItemId.Reset()
				if err := s.ItemId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"itemId\"")
			}
		case "nbtLookup":
			if err := func() error {
				s.NbtLookup.Reset()
				if err := s.NbtLookup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nbtLookup\"")
			}
		case "flatNbt":
			if err := func() error {
				s.FlatNbt.Reset()
				if err := s.FlatNbt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"flatNbt\"")
			}
		case "uId":
			if err := func() error {
				s.UID.Reset()
				if err := s.UID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uId\"")
			}
		case "findTime":
			if err := func() error {
				s.FindTime.Reset()
				if err := s.FindTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"findTime\"")
			}
		case "traceContext":
			if err := func() error {
				s.TraceContext.Reset()
				if err := s.TraceContext.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"traceContext\"")
			}
		case "context":
			if err := func() error {
				s.Context.Reset()
				if err := s.Context.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"context\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SaveAuction")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SaveAuction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SaveAuction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SaveAuctionContext) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SaveAuctionContext) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes SaveAuctionContext from json.
func (s *SaveAuctionContext) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SaveAuctionContext to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SaveAuctionContext")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SaveAuctionContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SaveAuctionContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SaveAuctionFlatNbt) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SaveAuctionFlatNbt) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes SaveAuctionFlatNbt from json.
func (s *SaveAuctionFlatNbt) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SaveAuctionFlatNbt to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SaveAuctionFlatNbt")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SaveAuctionFlatNbt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SaveAuctionFlatNbt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SaveAuctionTraceContext) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SaveAuctionTraceContext) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes SaveAuctionTraceContext from json.
func (s *SaveAuctionTraceContext) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SaveAuctionTraceContext to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SaveAuctionTraceContext")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SaveAuctionTraceContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SaveAuctionTraceContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SaveBids) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SaveBids) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Auction.Set {
			e.FieldStart("auction")
			s.Auction.Encode(e)
		}
	}
	{
		if s.Bidder.Set {
			e.FieldStart("bidder")
			s.Bidder.Encode(e)
		}
	}
	{
		if s.ProfileId.Set {
			e.FieldStart("profileId")
			s.ProfileId.Encode(e)
		}
	}
	{
		if s.Amount.Set {
			e.FieldStart("amount")
			s.Amount.Encode(e)
		}
	}
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.BidderId.Set {
			e.FieldStart("bidderId")
			s.BidderId.Encode(e)
		}
	}
}

var jsonFieldsNameOfSaveBids = [7]string{
	0: "id",
	1: "auction",
	2: "bidder",
	3: "profileId",
	4: "amount",
	5: "timestamp",
	6: "bidderId",
}

// Decode decodes SaveBids from json.
func (s *SaveBids) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SaveBids to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "auction":
			if err := func() error {
				s.Auction.Reset()
				if err := s.Auction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auction\"")
			}
		case "bidder":
			if err := func() error {
				s.Bidder.Reset()
				if err := s.Bidder.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bidder\"")
			}
		case "profileId":
			if err := func() error {
				s.ProfileId.Reset()
				if err := s.ProfileId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileId\"")
			}
		case "amount":
			if err := func() error {
				s.Amount.Reset()
				if err := s.Amount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "bidderId":
			if err := func() error {
				s.BidderId.Reset()
				if err := s.BidderId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bidderId\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SaveBids")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SaveBids) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SaveBids) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SkyblockAuctionsGetOKApplicationJSON as json.
func (s SkyblockAuctionsGetOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes SkyblockAuctionsGetOKApplicationJSON from json.
func (s *SkyblockAuctionsGetOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SkyblockAuctionsGetOKApplicationJSON to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SkyblockAuctionsGetOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SkyblockAuctionsGetOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SkyblockAuctionsGetOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SkyblockAuctionsPostOKApplicationJSON as json.
func (s SkyblockAuctionsPostOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes SkyblockAuctionsPostOKApplicationJSON from json.
func (s *SkyblockAuctionsPostOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SkyblockAuctionsPostOKApplicationJSON to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SkyblockAuctionsPostOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SkyblockAuctionsPostOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SkyblockAuctionsPostOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Tier as json.
func (s Tier) Encode(e *jx.Encoder) {
	e.Int32(int32(s))
}

// Decode decodes Tier from json.
func (s *Tier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Tier to nil")
	}
	v, err := d.Int32()
	if err != nil {
		return err
	}
	*s = Tier(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Tier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Tier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UUID) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UUID) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
}

var jsonFieldsNameOfUUID = [2]string{
	0: "id",
	1: "value",
}

// Decode decodes UUID from json.
func (s *UUID) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UUID to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UUID")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UUID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UUID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
